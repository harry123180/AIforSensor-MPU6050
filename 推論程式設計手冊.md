# Edge Impulse + Raspberry Pi Pico 2W 機器學習推論實作手冊

## 目錄
1. [Edge Impulse 專案建立與設定](#1-edge-impulse-專案建立與設定)
2. [資料收集與上傳](#2-資料收集與上傳)
3. [模型訓練設定](#3-模型訓練設定)
4. [模型部署與下載](#4-模型部署與下載)
5. [Arduino IDE 環境設定](#5-arduino-ide-環境設定)
6. [推論程式實作](#6-推論程式實作)
7. [常見問題與除錯](#7-常見問題與除錯)

---

## 1. Edge Impulse 專案建立與設定

### 1.1 建立新專案
1. 登入 [Edge Impulse](https://studio.edgeimpulse.com)
2. 點擊 **Create new project**
3. 輸入專案名稱
4. 選擇 **Developer** (個人開發者)

### 1.2 設定資料類型
**重要**: 選擇正確的感測器類型
- 選擇 **Accelerometer data** (加速度計)
- **不要選擇** Audio 或其他類型

### 1.3 設定資料參數
進入 **Dashboard** → **Project info** 設定：
- **Sensor**: Accelerometer
- **Frequency**: 1000 Hz
- **Axes**: 3 (X, Y, Z)

---

## 2. 資料收集與上傳

### 2.1 CSV 資料格式規範
```csv
timestamp,signal_x,signal_y,signal_z
0.0,0.125,-0.987,0.234
1.0,0.127,-0.985,0.235
2.0,0.124,-0.988,0.233
```

### 2.2 檔案命名規則
```
caseX.sampleY.csv
```
- `caseX`: 動作類別編號 (case0, case1, case2...)
- `sampleY`: 該類別的第Y個樣本

### 2.3 上傳資料
1. 進入 **Data acquisition**
2. 點擊 **Upload data**
3. 選擇 **Upload CSV**
4. 設定參數：
   - **Label**: 根據檔名設定 (如 case0)
   - **Sample rate**: 1000 Hz
   - **Sensor**: Accelerometer
5. 上傳所有訓練資料

### 2.4 資料分割
- **Training**: 80%
- **Testing**: 20%
- 使用 **Train/Test split** 功能自動分割

---

## 3. 模型訓練設定

### 3.1 創建 Impulse
進入 **Create impulse** 頁面：

#### Time series data (輸入區塊)
- **Window size**: 1000 ms
- **Window increase**: 1000 ms
- **Frequency**: 1000 Hz
- **Zero-pad data**: ✓ 勾選

#### Processing block (處理區塊)
選擇 **Spectral Analysis**：
- **Input axes**: signal_x, signal_y, signal_z
- **Type**: Spectral features
- **不要選擇** MFCC 或 MFE (這些是音訊用的)

#### Learning block (學習區塊)
選擇 **Classification**：
- **Input features**: Spectral features
- **Output features**: 根據類別數量

### 3.2 設定 Spectral features
1. 點擊 **Spectral features**
2. 參數設定：
   - **Scale axes**: 1
   - **Input decimation ratio**: 1
   - **Filter type**: None
   - **Filter cutoff frequency**: 保持預設
   - **Filter order**: 保持預設
3. 點擊 **Save parameters**
4. 點擊 **Generate features**

### 3.3 訓練神經網路
1. 點擊 **Classifier**
2. 神經網路架構建議：
   ```
   Input layer → Dense (20 neurons, ReLU) → Dense (10 neurons, ReLU) → Output layer
   ```
3. 訓練參數：
   - **Number of training cycles**: 100
   - **Learning rate**: 0.005
   - **Validation set size**: 20%
4. 點擊 **Start training**

### 3.4 評估模型
- **Accuracy**: 目標 > 85%
- **Loss**: 越低越好
- 檢查 **Confusion matrix** 確認分類效果

---

## 4. 模型部署與下載

### 4.1 部署設定
1. 進入 **Deployment**
2. 選擇 **Arduino library**
3. 優化選項：
   - **Enable EON Compiler**: ✓ (減少記憶體使用)
   - **Quantized (int8)**: 考慮勾選 (更小的模型)

### 4.2 下載函式庫
1. 點擊 **Build**
2. 等待編譯完成
3. 下載 `.zip` 檔案
4. 檔名格式：`專案名稱_inferencing.zip`

---

## 5. Arduino IDE 環境設定

### 5.1 安裝 Pico 2W 開發板支援
1. **檔案** → **偏好設定**
2. 在 **額外的開發板管理員網址** 加入：
   ```
   https://github.com/earlephilhower/arduino-pico/releases/download/global/package_rp2040_index.json
   ```
3. **工具** → **開發板** → **開發板管理員**
4. 搜尋 "RP2040" 並安裝

### 5.2 匯入 Edge Impulse 函式庫
1. **草稿碼** → **匯入程式庫** → **加入 .ZIP 程式庫**
2. 選擇下載的 `專案名稱_inferencing.zip`
3. 等待安裝完成

### 5.3 安裝相依函式庫
透過程式庫管理員安裝：
- Wire (內建)
- SPI (內建)

### 5.4 開發板設定
- **開發板**: Raspberry Pi Pico W
- **Flash Size**: 2MB (Sketch: 1MB, FS: 1MB)
- **CPU Speed**: 133 MHz
- **Upload Method**: Default (UF2)

---

## 6. 推論程式實作

### 6.1 基本架構
```cpp
#include <專案名稱_inferencing.h>
#include <Wire.h>

// MPU6050 設定
const int MPU = 0x68;
static float features[EI_CLASSIFIER_DSP_INPUT_FRAME_SIZE];

void setup() {
    Serial.begin(115200);
    
    // 初始化 I2C (Pico 2W 使用 I2C1)
    Wire1.setSDA(14);
    Wire1.setSCL(15);
    Wire1.begin();
    Wire1.setClock(400000);
    
    // 初始化 MPU6050
    initMPU6050();
}

void loop() {
    // 收集資料
    collectSamples();
    
    // 執行推論
    runInference();
    
    delay(100);
}
```

### 6.2 資料收集函式
```cpp
void collectSamples() {
    int feature_ix = 0;
    unsigned long last_sample_time = millis();
    
    // 收集 1000ms 的資料 (1000Hz)
    while (feature_ix < EI_CLASSIFIER_DSP_INPUT_FRAME_SIZE) {
        if (millis() - last_sample_time >= 1) {
            last_sample_time = millis();
            
            float accX, accY, accZ;
            readAcceleration(accX, accY, accZ);
            
            // 按順序存入：X, Y, Z
            features[feature_ix++] = accX;
            features[feature_ix++] = accY;
            features[feature_ix++] = accZ;
        }
    }
}
```

### 6.3 推論執行函式
```cpp
int raw_feature_get_data(size_t offset, size_t length, float *out_ptr) {
    memcpy(out_ptr, features + offset, length * sizeof(float));
    return 0;
}

void runInference() {
    // 建立 signal
    signal_t signal;
    signal.total_length = EI_CLASSIFIER_DSP_INPUT_FRAME_SIZE;
    signal.get_data = &raw_feature_get_data;
    
    // 執行分類器
    ei_impulse_result_t result = {0};
    EI_IMPULSE_ERROR res = run_classifier(&signal, &result, false);
    
    if (res != EI_IMPULSE_OK) {
        Serial.print("ERR: Failed to run classifier (");
        Serial.print(res);
        Serial.println(")");
        return;
    }
    
    // 輸出結果
    for (size_t ix = 0; ix < EI_CLASSIFIER_LABEL_COUNT; ix++) {
        Serial.print(result.classification[ix].label);
        Serial.print(": ");
        Serial.println(result.classification[ix].value);
    }
}
```

### 6.4 MPU6050 控制函式
```cpp
void initMPU6050() {
    writeRegister(0x6B, 0x00);  // 喚醒
    delay(100);
    writeRegister(0x1C, 0x00);  // ±2g
    writeRegister(0x19, 0x00);  // 1kHz 採樣率
}

void writeRegister(uint8_t reg, uint8_t value) {
    Wire1.beginTransmission(MPU);
    Wire1.write(reg);
    Wire1.write(value);
    Wire1.endTransmission();
}

void readAcceleration(float &accX, float &accY, float &accZ) {
    Wire1.beginTransmission(MPU);
    Wire1.write(0x3B);
    Wire1.endTransmission(false);
    Wire1.requestFrom(MPU, 6, true);
    
    if (Wire1.available() >= 6) {
        int16_t rawX = (Wire1.read() << 8) | Wire1.read();
        int16_t rawY = (Wire1.read() << 8) | Wire1.read();
        int16_t rawZ = (Wire1.read() << 8) | Wire1.read();
        
        accX = rawX / 16384.0;
        accY = rawY / 16384.0;
        accZ = rawZ / 16384.0;
    }
}
```

### 6.5 記憶體優化設定
在程式開頭加入：
```cpp
#define EIDSP_QUANTIZE_FILTERBANK   0
#define EI_CLASSIFIER_SLICES_PER_MODEL_WINDOW 1
```

---

## 7. 常見問題與除錯

### 7.1 編譯錯誤

#### 錯誤：記憶體不足
```
Sketch uses 164128 bytes (7%) of program storage space
```
**解決方案**：
- 使用 int8 量化模型
- 減少窗口大小
- 簡化神經網路架構

#### 錯誤：Unknown extract function
```
ERR: Unknown extract function, only MFCC, MFE and spectrogram supported
```
**解決方案**：
- 確認 Edge Impulse 專案選擇 Accelerometer 而非 Audio
- 使用 Spectral Analysis 而非 MFCC/MFE

### 7.2 執行錯誤

#### MPU6050 無回應
**檢查項目**：
1. 接線是否正確 (SDA→GP14, SCL→GP15)
2. I2C 地址是否為 0x68
3. 電源供應是否正常 (3.3V)

#### 推論結果異常
**檢查項目**：
1. 採樣頻率是否為 1000Hz
2. 資料順序是否為 X→Y→Z
3. 加速度範圍是否為 ±2g

### 7.3 效能優化建議

#### 提升推論速度
- 使用 EON Compiler
- 降低模型複雜度
- 使用 int8 量化

#### 提高準確度
- 增加訓練資料量
- 確保資料品質
- 調整神經網路架構

### 7.4 除錯輸出
加入除錯資訊：
```cpp
Serial.print("DSP time: ");
Serial.print(result.timing.dsp);
Serial.print(" ms, Classification time: ");
Serial.print(result.timing.classification);
Serial.println(" ms");
```

---

## 附錄：完整範例程式連結

完整的推論程式範例請參考前述對話中的程式碼，包含：
- 資料收集程式
- MPU6050 診斷程式
- Edge Impulse 推論程式

## 更新紀錄

- 2025.01 - 初版發布
- 支援 Raspberry Pi Pico 2W (RP2350)
- 支援 Edge Impulse Studio 最新版本

---

## 授權與貢獻

本手冊採用 MIT 授權，歡迎提出改進建議。